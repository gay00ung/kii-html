<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>얼굴인식 통합 분석 대시보드</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { max-width: 1600px; margin: 0 auto; }
        
        .header {
            text-align: center;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .upload-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin: 20px 0;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        /* 통합 분석 결과 섹션 */
        .analysis-summary {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 1em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-detail {
            font-size: 0.9em;
            color: #888;
        }
        
        .success { color: #4caf50; }
        .fail { color: #f44336; }
        
        /* 차트 섹션 */
        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .chart-container {
            position: relative;
            height: 400px;
        }
        
        /* 원래 대시보드 스타일 */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card h2 {
            color: #2a5298;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        
        .full-width-card {
            grid-column: 1 / -1;
        }
        
        /* 최적 조건 테이블 */
        .optimal-conditions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .optimal-conditions table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .optimal-conditions th, .optimal-conditions td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .optimal-conditions th {
            background: #e3f2fd;
            font-weight: bold;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 얼굴인식 통합 분석 대시보드</h1>
            <p>Liveness, Matching, Sensor 데이터를 통합 분석합니다</p>
        </div>
        
        <div class="upload-section">
            <h2>통합 CSV 파일 업로드</h2>
            <p>Liveness History, Matching History, Sensor Data가 포함된 CSV 파일을 선택해주세요</p>
            <div class="file-input-wrapper">
                <input type="file" id="csvFile" accept=".csv">
                <div class="file-input-button">📁 파일 선택</div>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>데이터 분석 중...</p>
            </div>
        </div>
        
        <!-- 통합 분석 요약 -->
        <div class="analysis-summary" id="analysisSummary">
            <h2>📊 전체 통계</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">전체 시도 횟수</div>
                    <div class="stat-value" id="totalAttempts">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Liveness 성공률</div>
                    <div class="stat-value" id="livenessRate">-%</div>
                    <div class="stat-detail">
                        <span class="success">성공: <span id="livenessSuccess">0</span></span> | 
                        <span class="fail">실패: <span id="livenessFail">0</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Matching 성공률</div>
                    <div class="stat-value" id="matchingRate">-%</div>
                    <div class="stat-detail">
                        <span class="success">성공: <span id="matchingSuccess">0</span></span> | 
                        <span class="fail">실패: <span id="matchingFail">0</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">완전 성공률</div>
                    <div class="stat-value" id="completeRate">-%</div>
                    <div class="stat-detail">Liveness & Matching 모두 성공</div>
                </div>
            </div>
            
            <!-- 최적 조건 분석 -->
            <div class="optimal-conditions" id="optimalConditions">
                <h3>✨ 최적 인증 조건</h3>
                <table>
                    <tr>
                        <th>조건</th>
                        <th>권장 범위</th>
                        <th>현재 상태</th>
                    </tr>
                    <tr>
                        <td>조도</td>
                        <td id="optimalLight">-</td>
                        <td id="currentLight">-</td>
                    </tr>
                    <tr>
                        <td>Pitch (상하)</td>
                        <td id="optimalPitch">-</td>
                        <td id="currentPitch">-</td>
                    </tr>
                    <tr>
                        <td>Yaw (좌우)</td>
                        <td id="optimalYaw">-</td>
                        <td id="currentYaw">-</td>
                    </tr>
                    <tr>
                        <td>Roll (기울임)</td>
                        <td id="optimalRoll">-</td>
                        <td id="currentRoll">-</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <!-- 차트 섹션 -->
        <div class="charts-section" id="chartsSection" style="display: none;">
            <div class="chart-card">
                <h2>📊 조명별 성공률</h2>
                <div class="chart-container">
                    <canvas id="lightSuccessChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>🎯 얼굴 방향 분포 (성공 vs 실패)</h2>
                <div class="chart-container">
                    <canvas id="orientationScatterChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>📈 매칭 점수 분포</h2>
                <div class="chart-container">
                    <canvas id="matchingScoreChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>🔥 센서 데이터 상관관계</h2>
                <div class="chart-container">
                    <canvas id="correlationChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- 기존 센서 분석 대시보드 -->
        <div class="dashboard" id="dashboard" style="display: none;">
            <!-- 기존 카드들은 그대로 유지 -->
        </div>
    </div>
    
    <script>
        let analysisData = {
            liveness: [],
            matching: [],
            sensor: [],
            merged: []
        };
        
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('loading').classList.add('active');
                parseIntegratedCSV(file);
            }
        });
        
        function parseIntegratedCSV(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const lines = content.split('\n');
                
                // 테이블 섹션 찾기
                let currentSection = null;
                let sectionData = {
                    liveness: [],
                    matching: [],
                    sensor: []
                };
                
                lines.forEach(line => {
                    if (line.includes('Table: Liveness History')) {
                        currentSection = 'liveness';
                    } else if (line.includes('Table: Matching History')) {
                        currentSection = 'matching';
                    } else if (line.includes('Table: Sensor Data')) {
                        currentSection = 'sensor';
                    } else if (currentSection && line.trim()) {
                        sectionData[currentSection].push(line);
                    }
                });
                
                // 각 섹션 파싱
                parseSection('liveness', sectionData.liveness);
                parseSection('matching', sectionData.matching);
                parseSection('sensor', sectionData.sensor);
                
                // 데이터 병합 및 분석
                mergeAndAnalyze();
                
                document.getElementById('loading').classList.remove('active');
                document.getElementById('analysisSummary').style.display = 'block';
                document.getElementById('chartsSection').style.display = 'grid';
            };
            reader.readAsText(file);
        }
        
        function parseSection(type, lines) {
            if (lines.length < 2) return;
            
            const headers = parseCSVLine(lines[0]);
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length === headers.length) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });
                    data.push(row);
                }
            }
            
            analysisData[type] = data;
        }
        
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());
            
            return values.map(v => v.replace(/^"|"$/g, ''));
        }
        
        function mergeAndAnalyze() {
            // ID로 데이터 병합
            const mergedData = {};
            
            // Liveness 데이터 처리
            analysisData.liveness.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = {};
                mergedData[id].liveness = {
                    result: parseInt(row.Result) === 1 ? 1 : 0,  // -6 같은 값도 0으로 처리
                    score: parseFloat(row.Score)
                };
            });
            
            // Matching 데이터 처리
            analysisData.matching.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = {};
                // Result 값 변환: 1=성공, 2,3=실패
                const result = parseInt(row.Result);
                mergedData[id].matching = {
                    result: result === 1 ? 1 : 0,
                    score: parseFloat(row.Score),
                    threshold: parseFloat(row['Threshold Score']),
                    message: row.Message
                };
            });
            
            // Sensor 데이터 처리
            analysisData.sensor.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = {};
                
                const eulerAngles = row['Euler Angles (X,Y,Z)'].split(',').map(v => parseFloat(v));
                mergedData[id].sensor = {
                    eulerX: eulerAngles[0],
                    eulerY: eulerAngles[1],
                    eulerZ: eulerAngles[2],
                    ambientLight: parseFloat(row['Ambient Light'])
                };
            });
            
            // 배열로 변환
            analysisData.merged = Object.entries(mergedData).map(([id, data]) => ({
                id,
                ...data
            }));
            
            // 통계 계산 및 표시
            calculateStatistics();
            drawCharts();
        }
        
        function calculateStatistics() {
            const total = analysisData.merged.length;
            
            // Liveness 통계
            const livenessSuccess = analysisData.merged.filter(d => d.liveness && d.liveness.result === 1).length;
            const livenessFail = analysisData.merged.filter(d => d.liveness && d.liveness.result === 0).length;
            const livenessRate = (livenessSuccess / (livenessSuccess + livenessFail) * 100) || 0;
            
            // Matching 통계
            const matchingSuccess = analysisData.merged.filter(d => d.matching && d.matching.result === 1).length;
            const matchingFail = analysisData.merged.filter(d => d.matching && d.matching.result === 0).length;
            const matchingRate = (matchingSuccess / (matchingSuccess + matchingFail) * 100) || 0;
            
            // 완전 성공률
            const completeSuccess = analysisData.merged.filter(d => 
                d.liveness && d.liveness.result === 1 && 
                d.matching && d.matching.result === 1
            ).length;
            const completeRate = (completeSuccess / total * 100) || 0;
            
            // 화면에 표시
            document.getElementById('totalAttempts').textContent = total;
            document.getElementById('livenessRate').textContent = livenessRate.toFixed(1) + '%';
            document.getElementById('livenessSuccess').textContent = livenessSuccess;
            document.getElementById('livenessFail').textContent = livenessFail;
            document.getElementById('matchingRate').textContent = matchingRate.toFixed(1) + '%';
            document.getElementById('matchingSuccess').textContent = matchingSuccess;
            document.getElementById('matchingFail').textContent = matchingFail;
            document.getElementById('completeRate').textContent = completeRate.toFixed(1) + '%';
            
            // 최적 조건 계산
            calculateOptimalConditions();
        }
        
        function calculateOptimalConditions() {
            // 완전 성공 케이스만 필터링
            const successCases = analysisData.merged.filter(d => 
                d.liveness && d.liveness.result === 1 && 
                d.matching && d.matching.result === 1 &&
                d.sensor
            );
            
            if (successCases.length > 0) {
                // 조도 범위
                const lights = successCases.map(d => d.sensor.ambientLight).sort((a, b) => a - b);
                const lightQ1 = lights[Math.floor(lights.length * 0.25)];
                const lightQ3 = lights[Math.floor(lights.length * 0.75)];
                document.getElementById('optimalLight').textContent = `${lightQ1.toFixed(0)} ~ ${lightQ3.toFixed(0)} lux`;
                
                // 각도 범위
                const pitches = successCases.map(d => Math.abs(d.sensor.eulerX)).sort((a, b) => a - b);
                const yaws = successCases.map(d => Math.abs(d.sensor.eulerY)).sort((a, b) => a - b);
                const rolls = successCases.map(d => Math.abs(d.sensor.eulerZ)).sort((a, b) => a - b);
                
                document.getElementById('optimalPitch').textContent = `±${pitches[Math.floor(pitches.length * 0.75)].toFixed(1)}°`;
                document.getElementById('optimalYaw').textContent = `±${yaws[Math.floor(yaws.length * 0.75)].toFixed(1)}°`;
                document.getElementById('optimalRoll').textContent = `±${rolls[Math.floor(rolls.length * 0.75)].toFixed(1)}°`;
            }
        }
        
        function drawCharts() {
            // 1. 조명별 성공률 차트
            drawLightSuccessChart();
            
            // 2. 얼굴 방향 분포 차트
            drawOrientationScatterChart();
            
            // 3. 매칭 점수 분포 차트
            drawMatchingScoreChart();
            
            // 4. 상관관계 히트맵
            drawCorrelationChart();
        }
        
        function drawLightSuccessChart() {
            const lightBins = [
                { label: '매우어두움', min: 0, max: 50 },
                { label: '어두움', min: 50, max: 100 },
                { label: '보통', min: 100, max: 200 },
                { label: '밝음', min: 200, max: 300 },
                { label: '매우밝음', min: 300, max: 500 }
            ];
            
            const lightData = lightBins.map(bin => {
                const inBin = analysisData.merged.filter(d => 
                    d.sensor && 
                    d.sensor.ambientLight >= bin.min && 
                    d.sensor.ambientLight < bin.max
                );
                
                const livenessSuccess = inBin.filter(d => d.liveness && d.liveness.result === 1).length;
                const matchingSuccess = inBin.filter(d => d.matching && d.matching.result === 1).length;
                
                return {
                    label: bin.label,
                    livenessRate: inBin.length > 0 ? (livenessSuccess / inBin.length * 100) : 0,
                    matchingRate: inBin.length > 0 ? (matchingSuccess / inBin.length * 100) : 0,
                    count: inBin.length
                };
            });
            
            const ctx = document.getElementById('lightSuccessChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: lightData.map(d => d.label),
                    datasets: [
                        {
                            label: 'Liveness',
                            data: lightData.map(d => d.livenessRate),
                            backgroundColor: 'rgba(33, 150, 243, 0.7)',
                            borderColor: '#2196f3',
                            borderWidth: 2
                        },
                        {
                            label: 'Matching',
                            data: lightData.map(d => d.matchingRate),
                            backgroundColor: 'rgba(255, 152, 0, 0.7)',
                            borderColor: '#ff9800',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { callback: value => value + '%' }
                        }
                    }
                }
            });
        }
        
        function drawOrientationScatterChart() {
            const successData = analysisData.merged
                .filter(d => d.sensor && d.liveness && d.matching && 
                        d.liveness.result === 1 && d.matching.result === 1)
                .map(d => ({ x: d.sensor.eulerY, y: d.sensor.eulerX }));
                
            const failData = analysisData.merged
                .filter(d => d.sensor && 
                        ((d.liveness && d.liveness.result === 0) || 
                         (d.matching && d.matching.result === 0)))
                .map(d => ({ x: d.sensor.eulerY, y: d.sensor.eulerX }));
            
            const ctx = document.getElementById('orientationScatterChart').getContext('2d');
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '성공',
                            data: successData,
                            backgroundColor: 'rgba(76, 175, 80, 0.6)',
                            pointRadius: 6
                        },
                        {
                            label: '실패',
                            data: failData,
                            backgroundColor: 'rgba(244, 67, 54, 0.6)',
                            pointRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            title: { display: true, text: 'Yaw (좌우 회전)' },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        },
                        y: { 
                            title: { display: true, text: 'Pitch (상하 회전)' },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        }
                    }
                }
            });
        }
        
        function drawMatchingScoreChart() {
            const successScores = analysisData.merged
                .filter(d => d.matching && d.matching.result === 1)
                .map(d => d.matching.score);
                
            const failScores = analysisData.merged
                .filter(d => d.matching && d.matching.result === 0)
                .map(d => d.matching.score);
            
            const threshold = analysisData.merged
                .find(d => d.matching && d.matching.threshold)?.matching.threshold || 4100;
            
            const ctx = document.getElementById('matchingScoreChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['성공', '실패'],
                    datasets: [{
                        label: '평균 매칭 점수',
                        data: [
                            successScores.length > 0 ? successScores.reduce((a, b) => a + b) / successScores.length : 0,
                            failScores.length > 0 ? failScores.reduce((a, b) => a + b) / failScores.length : 0
                        ],
                        backgroundColor: ['rgba(76, 175, 80, 0.7)', 'rgba(244, 67, 54, 0.7)'],
                        borderColor: ['#4caf50', '#f44336'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: 5000
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                threshold: {
                                    type: 'line',
                                    yMin: threshold,
                                    yMax: threshold,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: `임계값: ${threshold}`,
                                        enabled: true,
                                        position: 'start'
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function drawCorrelationChart() {
            // 상관관계 계산을 위한 데이터 준비
            const validData = analysisData.merged.filter(d => d.sensor);
            
            if (validData.length > 0) {
                // 간단한 상관관계 시각화 (실제 상관계수 계산은 복잡하므로 시각적 표현만)
                const ctx = document.getElementById('correlationChart').getContext('2d');
                
                // Face Orientation Score 계산
                validData.forEach(d => {
                    if (d.sensor) {
                        const deviation = Math.sqrt(
                            Math.pow(d.sensor.eulerX, 2) + 
                            Math.pow(d.sensor.eulerY, 2) + 
                            Math.pow(d.sensor.eulerZ, 2)
                        );
                        d.sensor.faceOrientationScore = Math.max(0, 100 - (deviation / 45) * 100);
                    }
                });
                
                // 센서 데이터와 결과의 관계 표시
                new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: '조도 vs 정면응시점수',
                            data: validData.map(d => ({
                                x: d.sensor.ambientLight,
                                y: d.sensor.faceOrientationScore,
                                r: (d.liveness?.result === 1 && d.matching?.result === 1) ? 8 : 5
                            })),
                            backgroundColor: validData.map(d => 
                                (d.liveness?.result === 1 && d.matching?.result === 1) 
                                    ? 'rgba(76, 175, 80, 0.6)' 
                                    : 'rgba(244, 67, 54, 0.6)'
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: '조도 (lux)' }
                            },
                            y: {
                                title: { display: true, text: '정면 응시 점수' },
                                min: 0,
                                max: 100
                            }
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>