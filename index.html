<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>얼굴인식 통합 분석 대시보드</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { max-width: 1600px; margin: 0 auto; }
        
        .header {
            text-align: center;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .upload-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin: 20px 0;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        /* 통합 분석 결과 섹션 */
        .analysis-summary {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 1em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-detail {
            font-size: 0.9em;
            color: #888;
        }
        
        .success { color: #4caf50; }
        .fail { color: #f44336; }
        
        /* 차트 섹션 */
        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .chart-container {
            position: relative;
            height: 400px;
        }
        
        /* 원래 대시보드 스타일 */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card h2 {
            color: #2a5298;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        
        .full-width-card {
            grid-column: 1 / -1;
        }
        
        /* 최적 조건 테이블 */
        .optimal-conditions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .optimal-conditions table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .optimal-conditions th, .optimal-conditions td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .optimal-conditions th {
            background: #e3f2fd;
            font-weight: bold;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 얼굴인식 통합 분석 대시보드</h1>
            <p>Liveness, Matching, Sensor 데이터를 통합 분석합니다</p>
        </div>
        
        <div class="upload-section">
            <h2>CSV 파일 업로드</h2>
            <p>하나 또는 여러 개의 CSV 파일을 선택해주세요</p>
            <div class="file-input-wrapper">
                <input type="file" id="csvFile" accept=".csv" multiple>
                <div class="file-input-button">📁 파일 선택 (여러 개 가능)</div>
            </div>
            <div id="fileList" style="margin: 20px 0; text-align: left;"></div>
            <button id="analyzeButton" style="display: none; background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); color: white; padding: 12px 30px; border: none; border-radius: 50px; font-size: 1em; font-weight: bold; cursor: pointer; margin-top: 10px;">
                📊 분석 시작
            </button>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>데이터 분석 중...</p>
            </div>
        </div>
        
        <!-- 통합 분석 요약 -->
        <div class="analysis-summary" id="analysisSummary">
            <h2>📊 전체 통계</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">전체 시도 횟수</div>
                    <div class="stat-value" id="totalAttempts">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Liveness 성공률</div>
                    <div class="stat-value" id="livenessRate">-%</div>
                    <div class="stat-detail">
                        <span class="success">성공: <span id="livenessSuccess">0</span></span> | 
                        <span class="fail">실패: <span id="livenessFail">0</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Matching 성공률</div>
                    <div class="stat-value" id="matchingRate">-%</div>
                    <div class="stat-detail">
                        <span class="success">성공: <span id="matchingSuccess">0</span></span> | 
                        <span class="fail">실패: <span id="matchingFail">0</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">완전 성공률</div>
                    <div class="stat-value" id="completeRate">-%</div>
                    <div class="stat-detail">Liveness & Matching 모두 성공</div>
                </div>
            </div>
            
            <!-- 최적 조건 분석 -->
            <div class="optimal-conditions" id="optimalConditions">
                <h3>✨ 최적 인증 조건</h3>
                <table>
                    <tr>
                        <th>조건</th>
                        <th>권장 범위</th>
                        <th>현재 상태</th>
                    </tr>
                    <tr>
                        <td>조도</td>
                        <td id="optimalLight">-</td>
                        <td id="currentLight">-</td>
                    </tr>
                    <tr>
                        <td>Pitch (상하)</td>
                        <td id="optimalPitch">-</td>
                        <td id="currentPitch">-</td>
                    </tr>
                    <tr>
                        <td>Yaw (좌우)</td>
                        <td id="optimalYaw">-</td>
                        <td id="currentYaw">-</td>
                    </tr>
                    <tr>
                        <td>Roll (기울임)</td>
                        <td id="optimalRoll">-</td>
                        <td id="currentRoll">-</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <!-- 차트 섹션 -->
        <div class="charts-section" id="chartsSection" style="display: none;">
            <div class="chart-card">
                <h2>📊 조명별 성공률</h2>
                <div class="chart-container">
                    <canvas id="lightSuccessChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>🎯 얼굴 방향 분포 (성공 vs 실패)</h2>
                <div class="chart-container">
                    <canvas id="orientationScatterChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>📈 매칭 점수 분포</h2>
                <div class="chart-container">
                    <canvas id="matchingScoreChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>🔥 센서 데이터 상관관계</h2>
                <div class="chart-container">
                    <canvas id="correlationChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- 기존 센서 분석 대시보드 -->
        <div class="dashboard" id="dashboard" style="display: none;">
            <!-- 기존 카드들은 그대로 유지 -->
        </div>
    </div>
    
    <script>
        let analysisData = {
            liveness: [],
            matching: [],
            sensor: [],
            merged: []
        };
        
        let selectedFiles = [];
        let combinedData = {
            liveness: [],
            matching: [],
            sensor: []
        };
        
        // 파일 선택 이벤트
        document.getElementById('csvFile').addEventListener('change', function(e) {
            selectedFiles = Array.from(e.target.files);
            displayFileList();
        });
        
        // 선택된 파일 목록 표시
        function displayFileList() {
            const fileListDiv = document.getElementById('fileList');
            const analyzeButton = document.getElementById('analyzeButton');
            
            if (selectedFiles.length === 0) {
                fileListDiv.innerHTML = '';
                analyzeButton.style.display = 'none';
                return;
            }
            
            let html = '<h3>선택된 파일:</h3><ul style="list-style: none; padding: 0;">';
            selectedFiles.forEach((file, index) => {
                html += `<li style="padding: 5px; background: #f0f0f0; margin: 5px 0; border-radius: 5px;">
                    📄 ${file.name} (${(file.size / 1024).toFixed(2)} KB)
                    <button onclick="removeFile(${index})" style="float: right; background: #f44336; color: white; border: none; padding: 2px 10px; border-radius: 3px; cursor: pointer;">✕</button>
                </li>`;
            });
            html += '</ul>';
            
            fileListDiv.innerHTML = html;
            analyzeButton.style.display = 'inline-block';
        }
        
        // 파일 제거
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            displayFileList();
        }
        
        // 분석 시작 버튼
        document.getElementById('analyzeButton').addEventListener('click', function() {
            if (selectedFiles.length === 0) {
                alert('파일을 선택해주세요.');
                return;
            }
            
            document.getElementById('loading').classList.add('active');
            combinedData = { liveness: [], matching: [], sensor: [] };
            
            let processedCount = 0;
            
            // 각 파일을 순차적으로 처리
            selectedFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseIntegratedCSV(e.target.result, file.name);
                    processedCount++;
                    
                    // 모든 파일 처리 완료
                    if (processedCount === selectedFiles.length) {
                        finalizeAnalysis();
                    }
                };
                reader.readAsText(file);
            });
        });
        
        function parseIntegratedCSV(content, fileName) {
            const lines = content.split('\n');
            
            // 현재 파일의 데이터
            let currentFileData = {
                liveness: [],
                matching: [],
                sensor: [],
                fileName: fileName
            };
            
            // 테이블 섹션 찾기
            let currentSection = null;
            let sectionData = {
                liveness: [],
                matching: [],
                sensor: []
            };
            
            lines.forEach(line => {
                if (line.includes('Table: Liveness History')) {
                    currentSection = 'liveness';
                } else if (line.includes('Table: Matching History')) {
                    currentSection = 'matching';
                } else if (line.includes('Table: Sensor Data')) {
                    currentSection = 'sensor';
                } else if (currentSection && line.trim() && !line.includes('Table:')) {
                    sectionData[currentSection].push(line);
                }
            });
            
            // 각 섹션 파싱
            Object.keys(sectionData).forEach(type => {
                if (sectionData[type].length > 1) {
                    const headers = parseCSVLine(sectionData[type][0]);
                    
                    for (let i = 1; i < sectionData[type].length; i++) {
                        const values = parseCSVLine(sectionData[type][i]);
                        if (values.length === headers.length) {
                            const row = { _sourceFile: fileName };
                            headers.forEach((header, index) => {
                                row[header] = values[index];
                            });
                            currentFileData[type].push(row);
                            combinedData[type].push(row);
                        }
                    }
                }
            });
            
            console.log(`파일 처리 완료: ${fileName}`);
            console.log(`- Liveness: ${currentFileData.liveness.length}건`);
            console.log(`- Matching: ${currentFileData.matching.length}건`);
            console.log(`- Sensor: ${currentFileData.sensor.length}건`);
        }
        
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());
            
            return values.map(v => v.replace(/^"|"$/g, ''));
        }
        
        function finalizeAnalysis() {
            console.log('\n=== 전체 데이터 통합 완료 ===');
            console.log(`총 Liveness 데이터: ${combinedData.liveness.length}건`);
            console.log(`총 Matching 데이터: ${combinedData.matching.length}건`);
            console.log(`총 Sensor 데이터: ${combinedData.sensor.length}건`);
            
            // analysisData에 통합 데이터 할당
            analysisData.liveness = combinedData.liveness;
            analysisData.matching = combinedData.matching;
            analysisData.sensor = combinedData.sensor;
            
            // 데이터 병합 및 분석
            mergeAndAnalyze();
            
            // 파일별 통계 추가
            displayFileStatistics();
            
            document.getElementById('loading').classList.remove('active');
            document.getElementById('analysisSummary').style.display = 'block';
            document.getElementById('chartsSection').style.display = 'grid';
        }
        
        function displayFileStatistics() {
            // 파일별 통계 계산
            const fileStats = {};
            
            selectedFiles.forEach(file => {
                const fileName = file.name;
                fileStats[fileName] = {
                    liveness: combinedData.liveness.filter(d => d._sourceFile === fileName).length,
                    matching: combinedData.matching.filter(d => d._sourceFile === fileName).length,
                    sensor: combinedData.sensor.filter(d => d._sourceFile === fileName).length
                };
            });
            
            // 통계 표시를 위한 HTML 추가
            const summaryDiv = document.getElementById('analysisSummary');
            let statsHTML = '<div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 20px 0;">';
            statsHTML += '<h3>📁 파일별 데이터 통계</h3>';
            statsHTML += '<table style="width: 100%; border-collapse: collapse;">';
            statsHTML += '<tr style="background: #e3f2fd;"><th style="padding: 10px; text-align: left;">파일명</th><th style="padding: 10px;">Liveness</th><th style="padding: 10px;">Matching</th><th style="padding: 10px;">Sensor</th></tr>';
            
            Object.entries(fileStats).forEach(([fileName, stats]) => {
                statsHTML += `<tr style="border-bottom: 1px solid #e0e0e0;">
                    <td style="padding: 10px;">${fileName}</td>
                    <td style="padding: 10px; text-align: center;">${stats.liveness}</td>
                    <td style="padding: 10px; text-align: center;">${stats.matching}</td>
                    <td style="padding: 10px; text-align: center;">${stats.sensor}</td>
                </tr>`;
            });
            
            statsHTML += '</table></div>';
            
            // 기존 통계 다음에 추가
            const existingStats = summaryDiv.querySelector('.stats-grid');
            existingStats.insertAdjacentHTML('afterend', statsHTML);
        }
        
        function mergeAndAnalyze() {
            // ID로 데이터 병합
            const mergedData = {};
            
            // Liveness 데이터 처리
            analysisData.liveness.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = { _sourceFiles: [] };
                
                // 어느 파일에서 왔는지 기록
                if (row._sourceFile && !mergedData[id]._sourceFiles.includes(row._sourceFile)) {
                    mergedData[id]._sourceFiles.push(row._sourceFile);
                }
                
                mergedData[id].liveness = {
                    result: parseInt(row.Result) === 1 ? 1 : 0,
                    score: parseFloat(row.Score),
                    sourceFile: row._sourceFile
                };
            });
            
            // Matching 데이터 처리
            analysisData.matching.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = { _sourceFiles: [] };
                
                if (row._sourceFile && !mergedData[id]._sourceFiles.includes(row._sourceFile)) {
                    mergedData[id]._sourceFiles.push(row._sourceFile);
                }
                
                const result = parseInt(row.Result);
                mergedData[id].matching = {
                    result: result === 1 ? 1 : 0,
                    score: parseFloat(row.Score),
                    threshold: parseFloat(row['Threshold Score']),
                    message: row.Message,
                    sourceFile: row._sourceFile
                };
            });
            
            // Sensor 데이터 처리
            analysisData.sensor.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = { _sourceFiles: [] };
                
                if (row._sourceFile && !mergedData[id]._sourceFiles.includes(row._sourceFile)) {
                    mergedData[id]._sourceFiles.push(row._sourceFile);
                }
                
                const eulerAngles = row['Euler Angles (X,Y,Z)'].split(',').map(v => parseFloat(v));
                mergedData[id].sensor = {
                    eulerX: eulerAngles[0],
                    eulerY: eulerAngles[1],
                    eulerZ: eulerAngles[2],
                    ambientLight: parseFloat(row['Ambient Light']),
                    sourceFile: row._sourceFile
                };
            });
            
            // 배열로 변환
            analysisData.merged = Object.entries(mergedData).map(([id, data]) => ({
                id,
                ...data
            }));
            
            console.log(`병합된 고유 ID 수: ${analysisData.merged.length}`);
            
            // 통계 계산 및 표시
            calculateStatistics();
            drawCharts();
        }
        
        function calculateStatistics() {
            const total = analysisData.merged.length;
            
            // Liveness 통계
            const livenessSuccess = analysisData.merged.filter(d => d.liveness && d.liveness.result === 1).length;
            const livenessFail = analysisData.merged.filter(d => d.liveness && d.liveness.result === 0).length;
            const livenessRate = (livenessSuccess / (livenessSuccess + livenessFail) * 100) || 0;
            
            // Matching 통계
            const matchingSuccess = analysisData.merged.filter(d => d.matching && d.matching.result === 1).length;
            const matchingFail = analysisData.merged.filter(d => d.matching && d.matching.result === 0).length;
            const matchingRate = (matchingSuccess / (matchingSuccess + matchingFail) * 100) || 0;
            
            // 완전 성공률
            const completeSuccess = analysisData.merged.filter(d => 
                d.liveness && d.liveness.result === 1 && 
                d.matching && d.matching.result === 1
            ).length;
            const completeRate = (completeSuccess / total * 100) || 0;
            
            // 화면에 표시
            document.getElementById('totalAttempts').textContent = total;
            document.getElementById('livenessRate').textContent = livenessRate.toFixed(1) + '%';
            document.getElementById('livenessSuccess').textContent = livenessSuccess;
            document.getElementById('livenessFail').textContent = livenessFail;
            document.getElementById('matchingRate').textContent = matchingRate.toFixed(1) + '%';
            document.getElementById('matchingSuccess').textContent = matchingSuccess;
            document.getElementById('matchingFail').textContent = matchingFail;
            document.getElementById('completeRate').textContent = completeRate.toFixed(1) + '%';
            
            // 최적 조건 계산
            calculateOptimalConditions();
        }
        
        function calculateOptimalConditions() {
            // 완전 성공 케이스만 필터링
            const successCases = analysisData.merged.filter(d => 
                d.liveness && d.liveness.result === 1 && 
                d.matching && d.matching.result === 1 &&
                d.sensor
            );
            
            if (successCases.length > 0) {
                // 조도 범위
                const lights = successCases.map(d => d.sensor.ambientLight).sort((a, b) => a - b);
                const lightQ1 = lights[Math.floor(lights.length * 0.25)];
                const lightQ3 = lights[Math.floor(lights.length * 0.75)];
                document.getElementById('optimalLight').textContent = `${lightQ1.toFixed(0)} ~ ${lightQ3.toFixed(0)} lux`;
                
                // 각도 범위
                const pitches = successCases.map(d => Math.abs(d.sensor.eulerX)).sort((a, b) => a - b);
                const yaws = successCases.map(d => Math.abs(d.sensor.eulerY)).sort((a, b) => a - b);
                const rolls = successCases.map(d => Math.abs(d.sensor.eulerZ)).sort((a, b) => a - b);
                
                document.getElementById('optimalPitch').textContent = `±${pitches[Math.floor(pitches.length * 0.75)].toFixed(1)}°`;
                document.getElementById('optimalYaw').textContent = `±${yaws[Math.floor(yaws.length * 0.75)].toFixed(1)}°`;
                document.getElementById('optimalRoll').textContent = `±${rolls[Math.floor(rolls.length * 0.75)].toFixed(1)}°`;
            }
        }
        
        function drawCharts() {
            // 1. 조명별 성공률 차트
            drawLightSuccessChart();
            
            // 2. 얼굴 방향 분포 차트
            drawOrientationScatterChart();
            
            // 3. 매칭 점수 분포 차트
            drawMatchingScoreChart();
            
            // 4. 상관관계 히트맵
            drawCorrelationChart();
        }
        
        function drawLightSuccessChart() {
            const lightBins = [
                { label: '매우어두움', min: 0, max: 50 },
                { label: '어두움', min: 50, max: 100 },
                { label: '보통', min: 100, max: 200 },
                { label: '밝음', min: 200, max: 300 },
                { label: '매우밝음', min: 300, max: 500 }
            ];
            
            const lightData = lightBins.map(bin => {
                const inBin = analysisData.merged.filter(d => 
                    d.sensor && 
                    d.sensor.ambientLight >= bin.min && 
                    d.sensor.ambientLight < bin.max
                );
                
                const livenessSuccess = inBin.filter(d => d.liveness && d.liveness.result === 1).length;
                const matchingSuccess = inBin.filter(d => d.matching && d.matching.result === 1).length;
                
                return {
                    label: bin.label,
                    livenessRate: inBin.length > 0 ? (livenessSuccess / inBin.length * 100) : 0,
                    matchingRate: inBin.length > 0 ? (matchingSuccess / inBin.length * 100) : 0,
                    count: inBin.length
                };
            });
            
            const ctx = document.getElementById('lightSuccessChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: lightData.map(d => d.label),
                    datasets: [
                        {
                            label: 'Liveness',
                            data: lightData.map(d => d.livenessRate),
                            backgroundColor: 'rgba(33, 150, 243, 0.7)',
                            borderColor: '#2196f3',
                            borderWidth: 2
                        },
                        {
                            label: 'Matching',
                            data: lightData.map(d => d.matchingRate),
                            backgroundColor: 'rgba(255, 152, 0, 0.7)',
                            borderColor: '#ff9800',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { callback: value => value + '%' }
                        }
                    }
                }
            });
        }
        
        function drawOrientationScatterChart() {
            const successData = analysisData.merged
                .filter(d => d.sensor && d.liveness && d.matching && 
                        d.liveness.result === 1 && d.matching.result === 1)
                .map(d => ({ x: d.sensor.eulerY, y: d.sensor.eulerX }));
                
            const failData = analysisData.merged
                .filter(d => d.sensor && 
                        ((d.liveness && d.liveness.result === 0) || 
                         (d.matching && d.matching.result === 0)))
                .map(d => ({ x: d.sensor.eulerY, y: d.sensor.eulerX }));
            
            const ctx = document.getElementById('orientationScatterChart').getContext('2d');
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '성공',
                            data: successData,
                            backgroundColor: 'rgba(76, 175, 80, 0.6)',
                            pointRadius: 6
                        },
                        {
                            label: '실패',
                            data: failData,
                            backgroundColor: 'rgba(244, 67, 54, 0.6)',
                            pointRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            title: { display: true, text: 'Yaw (좌우 회전)' },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        },
                        y: { 
                            title: { display: true, text: 'Pitch (상하 회전)' },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        }
                    }
                }
            });
        }
        
        function drawMatchingScoreChart() {
            const successScores = analysisData.merged
                .filter(d => d.matching && d.matching.result === 1)
                .map(d => d.matching.score);
                
            const failScores = analysisData.merged
                .filter(d => d.matching && d.matching.result === 0)
                .map(d => d.matching.score);
            
            const threshold = analysisData.merged
                .find(d => d.matching && d.matching.threshold)?.matching.threshold || 4100;
            
            const ctx = document.getElementById('matchingScoreChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['성공', '실패'],
                    datasets: [{
                        label: '평균 매칭 점수',
                        data: [
                            successScores.length > 0 ? successScores.reduce((a, b) => a + b) / successScores.length : 0,
                            failScores.length > 0 ? failScores.reduce((a, b) => a + b) / failScores.length : 0
                        ],
                        backgroundColor: ['rgba(76, 175, 80, 0.7)', 'rgba(244, 67, 54, 0.7)'],
                        borderColor: ['#4caf50', '#f44336'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: 5000
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                threshold: {
                                    type: 'line',
                                    yMin: threshold,
                                    yMax: threshold,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: `임계값: ${threshold}`,
                                        enabled: true,
                                        position: 'start'
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function drawCorrelationChart() {
            // 상관관계 계산을 위한 데이터 준비
            const validData = analysisData.merged.filter(d => d.sensor);
            
            if (validData.length > 0) {
                // 간단한 상관관계 시각화 (실제 상관계수 계산은 복잡하므로 시각적 표현만)
                const ctx = document.getElementById('correlationChart').getContext('2d');
                
                // Face Orientation Score 계산
                validData.forEach(d => {
                    if (d.sensor) {
                        const deviation = Math.sqrt(
                            Math.pow(d.sensor.eulerX, 2) + 
                            Math.pow(d.sensor.eulerY, 2) + 
                            Math.pow(d.sensor.eulerZ, 2)
                        );
                        d.sensor.faceOrientationScore = Math.max(0, 100 - (deviation / 45) * 100);
                    }
                });
                
                // 센서 데이터와 결과의 관계 표시
                new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: '조도 vs 정면응시점수',
                            data: validData.map(d => ({
                                x: d.sensor.ambientLight,
                                y: d.sensor.faceOrientationScore,
                                r: (d.liveness?.result === 1 && d.matching?.result === 1) ? 8 : 5
                            })),
                            backgroundColor: validData.map(d => 
                                (d.liveness?.result === 1 && d.matching?.result === 1) 
                                    ? 'rgba(76, 175, 80, 0.6)' 
                                    : 'rgba(244, 67, 54, 0.6)'
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: '조도 (lux)' }
                            },
                            y: {
                                title: { display: true, text: '정면 응시 점수' },
                                min: 0,
                                max: 100
                            }
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>