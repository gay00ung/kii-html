<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì–¼êµ´ì¸ì‹ í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { max-width: 1600px; margin: 0 auto; }
        
        .header {
            text-align: center;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }
        
        .upload-section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin: 20px 0;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        /* í†µí•© ë¶„ì„ ê²°ê³¼ ì„¹ì…˜ */
        .analysis-summary {
            background: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 10px 0;
        }
        
        .stat-label {
            font-size: 1em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-detail {
            font-size: 0.9em;
            color: #888;
        }
        
        .success { color: #4caf50; }
        .fail { color: #f44336; }
        
        /* ì°¨íŠ¸ ì„¹ì…˜ */
        .charts-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .chart-container {
            position: relative;
            height: 400px;
        }
        
        /* ì›ë˜ ëŒ€ì‹œë³´ë“œ ìŠ¤íƒ€ì¼ */
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card h2 {
            color: #2a5298;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        
        .full-width-card {
            grid-column: 1 / -1;
        }
        
        /* ìµœì  ì¡°ê±´ í…Œì´ë¸” */
        .optimal-conditions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .optimal-conditions table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .optimal-conditions th, .optimal-conditions td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .optimal-conditions th {
            background: #e3f2fd;
            font-weight: bold;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ ì–¼êµ´ì¸ì‹ í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ</h1>
            <p>Liveness, Matching, Sensor ë°ì´í„°ë¥¼ í†µí•© ë¶„ì„í•©ë‹ˆë‹¤</p>
        </div>
        
        <div class="upload-section">
            <h2>í†µí•© CSV íŒŒì¼ ì—…ë¡œë“œ</h2>
            <p>Liveness History, Matching History, Sensor Dataê°€ í¬í•¨ëœ CSV íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”</p>
            <div class="file-input-wrapper">
                <input type="file" id="csvFile" accept=".csv">
                <div class="file-input-button">ğŸ“ íŒŒì¼ ì„ íƒ</div>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>ë°ì´í„° ë¶„ì„ ì¤‘...</p>
            </div>
        </div>
        
        <!-- í†µí•© ë¶„ì„ ìš”ì•½ -->
        <div class="analysis-summary" id="analysisSummary">
            <h2>ğŸ“Š ì „ì²´ í†µê³„</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">ì „ì²´ ì‹œë„ íšŸìˆ˜</div>
                    <div class="stat-value" id="totalAttempts">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Liveness ì„±ê³µë¥ </div>
                    <div class="stat-value" id="livenessRate">-%</div>
                    <div class="stat-detail">
                        <span class="success">ì„±ê³µ: <span id="livenessSuccess">0</span></span> | 
                        <span class="fail">ì‹¤íŒ¨: <span id="livenessFail">0</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Matching ì„±ê³µë¥ </div>
                    <div class="stat-value" id="matchingRate">-%</div>
                    <div class="stat-detail">
                        <span class="success">ì„±ê³µ: <span id="matchingSuccess">0</span></span> | 
                        <span class="fail">ì‹¤íŒ¨: <span id="matchingFail">0</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ì™„ì „ ì„±ê³µë¥ </div>
                    <div class="stat-value" id="completeRate">-%</div>
                    <div class="stat-detail">Liveness & Matching ëª¨ë‘ ì„±ê³µ</div>
                </div>
            </div>
            
            <!-- ìµœì  ì¡°ê±´ ë¶„ì„ -->
            <div class="optimal-conditions" id="optimalConditions">
                <h3>âœ¨ ìµœì  ì¸ì¦ ì¡°ê±´</h3>
                <table>
                    <tr>
                        <th>ì¡°ê±´</th>
                        <th>ê¶Œì¥ ë²”ìœ„</th>
                        <th>í˜„ì¬ ìƒíƒœ</th>
                    </tr>
                    <tr>
                        <td>ì¡°ë„</td>
                        <td id="optimalLight">-</td>
                        <td id="currentLight">-</td>
                    </tr>
                    <tr>
                        <td>Pitch (ìƒí•˜)</td>
                        <td id="optimalPitch">-</td>
                        <td id="currentPitch">-</td>
                    </tr>
                    <tr>
                        <td>Yaw (ì¢Œìš°)</td>
                        <td id="optimalYaw">-</td>
                        <td id="currentYaw">-</td>
                    </tr>
                    <tr>
                        <td>Roll (ê¸°ìš¸ì„)</td>
                        <td id="optimalRoll">-</td>
                        <td id="currentRoll">-</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <!-- ì°¨íŠ¸ ì„¹ì…˜ -->
        <div class="charts-section" id="chartsSection" style="display: none;">
            <div class="chart-card">
                <h2>ğŸ“Š ì¡°ëª…ë³„ ì„±ê³µë¥ </h2>
                <div class="chart-container">
                    <canvas id="lightSuccessChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>ğŸ¯ ì–¼êµ´ ë°©í–¥ ë¶„í¬ (ì„±ê³µ vs ì‹¤íŒ¨)</h2>
                <div class="chart-container">
                    <canvas id="orientationScatterChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>ğŸ“ˆ ë§¤ì¹­ ì ìˆ˜ ë¶„í¬</h2>
                <div class="chart-container">
                    <canvas id="matchingScoreChart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <h2>ğŸ”¥ ì„¼ì„œ ë°ì´í„° ìƒê´€ê´€ê³„</h2>
                <div class="chart-container">
                    <canvas id="correlationChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- ê¸°ì¡´ ì„¼ì„œ ë¶„ì„ ëŒ€ì‹œë³´ë“œ -->
        <div class="dashboard" id="dashboard" style="display: none;">
            <!-- ê¸°ì¡´ ì¹´ë“œë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€ -->
        </div>
    </div>
    
    <script>
        let analysisData = {
            liveness: [],
            matching: [],
            sensor: [],
            merged: []
        };
        
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('loading').classList.add('active');
                parseIntegratedCSV(file);
            }
        });
        
        function parseIntegratedCSV(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const lines = content.split('\n');
                
                // í…Œì´ë¸” ì„¹ì…˜ ì°¾ê¸°
                let currentSection = null;
                let sectionData = {
                    liveness: [],
                    matching: [],
                    sensor: []
                };
                
                lines.forEach(line => {
                    if (line.includes('Table: Liveness History')) {
                        currentSection = 'liveness';
                    } else if (line.includes('Table: Matching History')) {
                        currentSection = 'matching';
                    } else if (line.includes('Table: Sensor Data')) {
                        currentSection = 'sensor';
                    } else if (currentSection && line.trim()) {
                        sectionData[currentSection].push(line);
                    }
                });
                
                // ê° ì„¹ì…˜ íŒŒì‹±
                parseSection('liveness', sectionData.liveness);
                parseSection('matching', sectionData.matching);
                parseSection('sensor', sectionData.sensor);
                
                // ë°ì´í„° ë³‘í•© ë° ë¶„ì„
                mergeAndAnalyze();
                
                document.getElementById('loading').classList.remove('active');
                document.getElementById('analysisSummary').style.display = 'block';
                document.getElementById('chartsSection').style.display = 'grid';
            };
            reader.readAsText(file);
        }
        
        function parseSection(type, lines) {
            if (lines.length < 2) return;
            
            const headers = parseCSVLine(lines[0]);
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length === headers.length) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });
                    data.push(row);
                }
            }
            
            analysisData[type] = data;
        }
        
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());
            
            return values.map(v => v.replace(/^"|"$/g, ''));
        }
        
        function mergeAndAnalyze() {
            // IDë¡œ ë°ì´í„° ë³‘í•©
            const mergedData = {};
            
            // Liveness ë°ì´í„° ì²˜ë¦¬
            analysisData.liveness.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = {};
                mergedData[id].liveness = {
                    result: parseInt(row.Result) === 1 ? 1 : 0,  // -6 ê°™ì€ ê°’ë„ 0ìœ¼ë¡œ ì²˜ë¦¬
                    score: parseFloat(row.Score)
                };
            });
            
            // Matching ë°ì´í„° ì²˜ë¦¬
            analysisData.matching.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = {};
                // Result ê°’ ë³€í™˜: 1=ì„±ê³µ, 2,3=ì‹¤íŒ¨
                const result = parseInt(row.Result);
                mergedData[id].matching = {
                    result: result === 1 ? 1 : 0,
                    score: parseFloat(row.Score),
                    threshold: parseFloat(row['Threshold Score']),
                    message: row.Message
                };
            });
            
            // Sensor ë°ì´í„° ì²˜ë¦¬
            analysisData.sensor.forEach(row => {
                const id = row.ID;
                if (!mergedData[id]) mergedData[id] = {};
                
                const eulerAngles = row['Euler Angles (X,Y,Z)'].split(',').map(v => parseFloat(v));
                mergedData[id].sensor = {
                    eulerX: eulerAngles[0],
                    eulerY: eulerAngles[1],
                    eulerZ: eulerAngles[2],
                    ambientLight: parseFloat(row['Ambient Light'])
                };
            });
            
            // ë°°ì—´ë¡œ ë³€í™˜
            analysisData.merged = Object.entries(mergedData).map(([id, data]) => ({
                id,
                ...data
            }));
            
            // í†µê³„ ê³„ì‚° ë° í‘œì‹œ
            calculateStatistics();
            drawCharts();
        }
        
        function calculateStatistics() {
            const total = analysisData.merged.length;
            
            // Liveness í†µê³„
            const livenessSuccess = analysisData.merged.filter(d => d.liveness && d.liveness.result === 1).length;
            const livenessFail = analysisData.merged.filter(d => d.liveness && d.liveness.result === 0).length;
            const livenessRate = (livenessSuccess / (livenessSuccess + livenessFail) * 100) || 0;
            
            // Matching í†µê³„
            const matchingSuccess = analysisData.merged.filter(d => d.matching && d.matching.result === 1).length;
            const matchingFail = analysisData.merged.filter(d => d.matching && d.matching.result === 0).length;
            const matchingRate = (matchingSuccess / (matchingSuccess + matchingFail) * 100) || 0;
            
            // ì™„ì „ ì„±ê³µë¥ 
            const completeSuccess = analysisData.merged.filter(d => 
                d.liveness && d.liveness.result === 1 && 
                d.matching && d.matching.result === 1
            ).length;
            const completeRate = (completeSuccess / total * 100) || 0;
            
            // í™”ë©´ì— í‘œì‹œ
            document.getElementById('totalAttempts').textContent = total;
            document.getElementById('livenessRate').textContent = livenessRate.toFixed(1) + '%';
            document.getElementById('livenessSuccess').textContent = livenessSuccess;
            document.getElementById('livenessFail').textContent = livenessFail;
            document.getElementById('matchingRate').textContent = matchingRate.toFixed(1) + '%';
            document.getElementById('matchingSuccess').textContent = matchingSuccess;
            document.getElementById('matchingFail').textContent = matchingFail;
            document.getElementById('completeRate').textContent = completeRate.toFixed(1) + '%';
            
            // ìµœì  ì¡°ê±´ ê³„ì‚°
            calculateOptimalConditions();
        }
        
        function calculateOptimalConditions() {
            // ì™„ì „ ì„±ê³µ ì¼€ì´ìŠ¤ë§Œ í•„í„°ë§
            const successCases = analysisData.merged.filter(d => 
                d.liveness && d.liveness.result === 1 && 
                d.matching && d.matching.result === 1 &&
                d.sensor
            );
            
            if (successCases.length > 0) {
                // ì¡°ë„ ë²”ìœ„
                const lights = successCases.map(d => d.sensor.ambientLight).sort((a, b) => a - b);
                const lightQ1 = lights[Math.floor(lights.length * 0.25)];
                const lightQ3 = lights[Math.floor(lights.length * 0.75)];
                document.getElementById('optimalLight').textContent = `${lightQ1.toFixed(0)} ~ ${lightQ3.toFixed(0)} lux`;
                
                // ê°ë„ ë²”ìœ„
                const pitches = successCases.map(d => Math.abs(d.sensor.eulerX)).sort((a, b) => a - b);
                const yaws = successCases.map(d => Math.abs(d.sensor.eulerY)).sort((a, b) => a - b);
                const rolls = successCases.map(d => Math.abs(d.sensor.eulerZ)).sort((a, b) => a - b);
                
                document.getElementById('optimalPitch').textContent = `Â±${pitches[Math.floor(pitches.length * 0.75)].toFixed(1)}Â°`;
                document.getElementById('optimalYaw').textContent = `Â±${yaws[Math.floor(yaws.length * 0.75)].toFixed(1)}Â°`;
                document.getElementById('optimalRoll').textContent = `Â±${rolls[Math.floor(rolls.length * 0.75)].toFixed(1)}Â°`;
            }
        }
        
        function drawCharts() {
            // 1. ì¡°ëª…ë³„ ì„±ê³µë¥  ì°¨íŠ¸
            drawLightSuccessChart();
            
            // 2. ì–¼êµ´ ë°©í–¥ ë¶„í¬ ì°¨íŠ¸
            drawOrientationScatterChart();
            
            // 3. ë§¤ì¹­ ì ìˆ˜ ë¶„í¬ ì°¨íŠ¸
            drawMatchingScoreChart();
            
            // 4. ìƒê´€ê´€ê³„ íˆíŠ¸ë§µ
            drawCorrelationChart();
        }
        
        function drawLightSuccessChart() {
            const lightBins = [
                { label: 'ë§¤ìš°ì–´ë‘ì›€', min: 0, max: 50 },
                { label: 'ì–´ë‘ì›€', min: 50, max: 100 },
                { label: 'ë³´í†µ', min: 100, max: 200 },
                { label: 'ë°ìŒ', min: 200, max: 300 },
                { label: 'ë§¤ìš°ë°ìŒ', min: 300, max: 500 }
            ];
            
            const lightData = lightBins.map(bin => {
                const inBin = analysisData.merged.filter(d => 
                    d.sensor && 
                    d.sensor.ambientLight >= bin.min && 
                    d.sensor.ambientLight < bin.max
                );
                
                const livenessSuccess = inBin.filter(d => d.liveness && d.liveness.result === 1).length;
                const matchingSuccess = inBin.filter(d => d.matching && d.matching.result === 1).length;
                
                return {
                    label: bin.label,
                    livenessRate: inBin.length > 0 ? (livenessSuccess / inBin.length * 100) : 0,
                    matchingRate: inBin.length > 0 ? (matchingSuccess / inBin.length * 100) : 0,
                    count: inBin.length
                };
            });
            
            const ctx = document.getElementById('lightSuccessChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: lightData.map(d => d.label),
                    datasets: [
                        {
                            label: 'Liveness',
                            data: lightData.map(d => d.livenessRate),
                            backgroundColor: 'rgba(33, 150, 243, 0.7)',
                            borderColor: '#2196f3',
                            borderWidth: 2
                        },
                        {
                            label: 'Matching',
                            data: lightData.map(d => d.matchingRate),
                            backgroundColor: 'rgba(255, 152, 0, 0.7)',
                            borderColor: '#ff9800',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { callback: value => value + '%' }
                        }
                    }
                }
            });
        }
        
        function drawOrientationScatterChart() {
            const successData = analysisData.merged
                .filter(d => d.sensor && d.liveness && d.matching && 
                        d.liveness.result === 1 && d.matching.result === 1)
                .map(d => ({ x: d.sensor.eulerY, y: d.sensor.eulerX }));
                
            const failData = analysisData.merged
                .filter(d => d.sensor && 
                        ((d.liveness && d.liveness.result === 0) || 
                         (d.matching && d.matching.result === 0)))
                .map(d => ({ x: d.sensor.eulerY, y: d.sensor.eulerX }));
            
            const ctx = document.getElementById('orientationScatterChart').getContext('2d');
            new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'ì„±ê³µ',
                            data: successData,
                            backgroundColor: 'rgba(76, 175, 80, 0.6)',
                            pointRadius: 6
                        },
                        {
                            label: 'ì‹¤íŒ¨',
                            data: failData,
                            backgroundColor: 'rgba(244, 67, 54, 0.6)',
                            pointRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            title: { display: true, text: 'Yaw (ì¢Œìš° íšŒì „)' },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        },
                        y: { 
                            title: { display: true, text: 'Pitch (ìƒí•˜ íšŒì „)' },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        }
                    }
                }
            });
        }
        
        function drawMatchingScoreChart() {
            const successScores = analysisData.merged
                .filter(d => d.matching && d.matching.result === 1)
                .map(d => d.matching.score);
                
            const failScores = analysisData.merged
                .filter(d => d.matching && d.matching.result === 0)
                .map(d => d.matching.score);
            
            const threshold = analysisData.merged
                .find(d => d.matching && d.matching.threshold)?.matching.threshold || 4100;
            
            const ctx = document.getElementById('matchingScoreChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['ì„±ê³µ', 'ì‹¤íŒ¨'],
                    datasets: [{
                        label: 'í‰ê·  ë§¤ì¹­ ì ìˆ˜',
                        data: [
                            successScores.length > 0 ? successScores.reduce((a, b) => a + b) / successScores.length : 0,
                            failScores.length > 0 ? failScores.reduce((a, b) => a + b) / failScores.length : 0
                        ],
                        backgroundColor: ['rgba(76, 175, 80, 0.7)', 'rgba(244, 67, 54, 0.7)'],
                        borderColor: ['#4caf50', '#f44336'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: 5000
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                threshold: {
                                    type: 'line',
                                    yMin: threshold,
                                    yMax: threshold,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        content: `ì„ê³„ê°’: ${threshold}`,
                                        enabled: true,
                                        position: 'start'
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function drawCorrelationChart() {
            // ìƒê´€ê´€ê³„ ê³„ì‚°ì„ ìœ„í•œ ë°ì´í„° ì¤€ë¹„
            const validData = analysisData.merged.filter(d => d.sensor);
            
            if (validData.length > 0) {
                // ê°„ë‹¨í•œ ìƒê´€ê´€ê³„ ì‹œê°í™” (ì‹¤ì œ ìƒê´€ê³„ìˆ˜ ê³„ì‚°ì€ ë³µì¡í•˜ë¯€ë¡œ ì‹œê°ì  í‘œí˜„ë§Œ)
                const ctx = document.getElementById('correlationChart').getContext('2d');
                
                // Face Orientation Score ê³„ì‚°
                validData.forEach(d => {
                    if (d.sensor) {
                        const deviation = Math.sqrt(
                            Math.pow(d.sensor.eulerX, 2) + 
                            Math.pow(d.sensor.eulerY, 2) + 
                            Math.pow(d.sensor.eulerZ, 2)
                        );
                        d.sensor.faceOrientationScore = Math.max(0, 100 - (deviation / 45) * 100);
                    }
                });
                
                // ì„¼ì„œ ë°ì´í„°ì™€ ê²°ê³¼ì˜ ê´€ê³„ í‘œì‹œ
                new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: 'ì¡°ë„ vs ì •ë©´ì‘ì‹œì ìˆ˜',
                            data: validData.map(d => ({
                                x: d.sensor.ambientLight,
                                y: d.sensor.faceOrientationScore,
                                r: (d.liveness?.result === 1 && d.matching?.result === 1) ? 8 : 5
                            })),
                            backgroundColor: validData.map(d => 
                                (d.liveness?.result === 1 && d.matching?.result === 1) 
                                    ? 'rgba(76, 175, 80, 0.6)' 
                                    : 'rgba(244, 67, 54, 0.6)'
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: { display: true, text: 'ì¡°ë„ (lux)' }
                            },
                            y: {
                                title: { display: true, text: 'ì •ë©´ ì‘ì‹œ ì ìˆ˜' },
                                min: 0,
                                max: 100
                            }
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>